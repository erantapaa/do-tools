#!/usr/bin/env python
#
# do-ssh  -- Manage Digital Ocean entries in a ssh config file.
#
# do-ssh sync [-c config-path]  -- add/remove DO hosts to a ssh config
# do-ssh list                   -- list DO hosts and ip addresse
# do-ssh ip hostname            -- return the ip of a hostname in a .ssh config

import sys
import os.path
import re
from subprocess import call , Popen, PIPE

import argparse

def make_parser():
  """Create the argument parser."""
  parser = argparse.ArgumentParser()

  subp = parser.add_subparsers(title = "Subcommands", dest="which")

  listp = subp.add_parser("list")

  showip = subp.add_parser("ip")
  showip.add_argument('hosts', nargs='*')
  showip.add_argument("-c", action="store", help="path to ssh config file")

  syncp = subp.add_parser("sync")
  syncp.add_argument("-c", action="store", help="path to ssh config file")
  syncp.add_argument("-o", action="store", help="path to ssh config file")
  syncp.add_argument("-n", action="store_true",
                     help="dry-run mode - emits config file to STDOUT")

  return parser

class error(Exception):
  def __init__(self, msg):
    self.msg = msg

class Stanza():
  def __init__(self, host, lines):
    self.host = host
    self.lines = lines
    self.attrs = None

  def properties(self):
    """Return the dictionary of properties."""
    if not self.attrs:
      self.attrs = self.__properties__() # generate the attribute value pairs
    return self.attrs

  def is_host_stanza(self):
    return self.host is not None

  def attr(self, name, default=None):
    return self.properties().get(name, default)

  def is_droplet(self):
    return self.is_host_stanza() and self.attr('__droplet__', False)

  def __properties__(self):
    """Return a dictionary of attribute values."""
    d = {}
    for x in self.lines:
      m = re.match("\s*(\w+)\s+(.*)", x)
      if m:
        d[ m.group(1).lower() ] = m.group(2)
      elif re.match("\s*# droplet", x):
        d[ "__droplet__" ] = True
    return d

  def format(self):
    return ''.join( [ x + '\n' for x in self.lines ] )

class SshConfig():
  def __init__(self, stanzas):
    self.stanzas = stanzas

  def stanza_attrs(self):
    """Iterate through the stanzas."""
    for s in self.stanzas:
      if s.is_host_stanza():
        d = s.properties()
      else:
        d = {}
      yield s.host, s, d

  def dump(self):
    for i, s in enumerate(self.stanzas, 1):
      h = s.host
      if s.host is None:
        h = "---"
      print "Stanza", i, " Host:", h
      for x in s.lines:
        print "  |" + x

  def format(self):
    """DEPRECATED - Reconstruct the config file - trimming any trailing blank lines"""
    content = ''.join([ s.format() for s in self.stanzas ])
    content = re.sub('\s+\Z', '\n', content)
    return content

  def serialize(self):
    """Reconstruct the config file - trimming any trailing blank lines"""
    content = ''.join([ s.format() for s in self.stanzas ])
    content = re.sub('\s+\Z', '\n', content)
    return content

  def append_stanza(self, s):
    self.stanzas.append(s)

  def replace_stanza_at(self, i, s):
    """Replace the stanza at i with s."""
    self.stanzas[i] = s

  def insert_stanza(self, i, s):
    self.stanzas.insert(i, s)

# types of stanzas:
#   - non-host group of lines
#   - a Host stanza

def find_by_host(config, host):
  """Find a stanza for a given Host name."""
  for i, s in enumerate(config.stanzas):
    if s.is_host_stanza() and host == s.host:
      return i
  return None

def find_do_entry_by_ipaddr(config, ipaddr):
  for i, s in enumerate(config.stanzas):
    if s.is_host_stanza() and s.is_droplet() and (ipaddr == s.attr("hostname")):
      return i
  return None

def find_by_ipaddr(config, ipaddr):
  """Find a stanza having an given IP address."""
  for i, s in enumerate(config.stanzas):

    if s.is_host_stanza() and (ipaddr == s.attr("hostname")):
      return i
  return None

def replace_stanza(config, ipaddr, stanza):
  i = find_by_ipaddr(config, ipaddr)
  if i is None:
    config.append_stanza(stanza)
  else:
    config.replace_stanza_at(i, stanza)

def add_stanza(config, ipaddr, stanza):
  """Add a stanza for an ip address."""
  if find_by_ipaddr(config, ipaddr) is None:
    config.append(stanza)
  else:
    raise "hostname already exists"

def add_do_stanza(config, ipaddr, stanza):
  """Add a Digital Ocean stanza by either replacing
     an exisit stanza or by inserting it before the '*' entry."""
  i = find_do_entry_by_ipaddr(config, ipaddr)
  if i is None:
    j = find_by_host(config, '*')
    if j is not None:
      config.insert_stanza(j, stanza)
    else:
      config.append_stanza(stanza)
  else:
    config.replace_stanza_at(i, stanza)

def del_stanza(config, ipaddr):
  """Remove a stanza for a hostname."""
  i = find_by_ipaddr(config, ipaddr)
  if i is not None:
    config.stanza.pop(i)
  return i

def parse_ssh_config(lines):
  """Returns a SshConfig object."""
  host = None
  stanzas = []
  s = []          # the current stanza
  for x in lines:
    m = re.match('\s*Host\s+(.*)', x)
    if m:
      if s:
        stanzas.append( Stanza(host, s) )
        host = m.group(1)
        s = []
    s.append(x)
  if s:
    stanzas.append( Stanza(host, s) )
  ssh_config = SshConfig(stanzas)
  return ssh_config

def cmd_list(config):
  droplets = [ s for s in config.stanzas if s.is_droplet() ]
  for s in droplets:
    host = s.host
    hname = s.attr('hostname', "???")
    user = s.attr('user', None)
    if user is None:
      u = ""
    else:
      u = " user: " + user
    print '{:<16} {:<20} {}'.format(hname, host, u)

def make_droplet_stanza(host, ip, user=None, idfile=None):
  name = host
  lines = ["Host " + name, "  # droplet", "  Hostname " + ip]
  if user:
    lines.append("  User " + user)
  if idfile:
    lines.append("  IdentityFile " + idfile)
  lines.append("")
  return Stanza(host, lines)

def add_droplet(config, host, ip, user=None, idfile=None):
  """Add a droplet stanza to a SshConfig."""
  stanza = make_droplet_stanza(host, ip, user, idfile)
  return add_do_stanza(config, ip, stanza)

def cmd_delete(config, name):
  """Delete all droplets matching name. Return the number of stanzas deleted."""
  new = []
  dropped = 0
  for s in config.stanzas:
    if s.is_droplet() and s.host == name:
      dropped += 1
      continue
    new.append(s)
  config.stanzas = new
  print "Removed entries:", dropped

def read_file(path):
  with open (path) as f:
    contents = f.read()
    return contents

def write_file(path, contents):
  with open(path, "w") as f:
    f.write(contents)

def read_ssh_config(path):
  lines = read_file(path).split('\n')
  c = parse_ssh_config(lines)
  return c

def collect_stdout(cmd):
  return Popen(cmd, stdout=PIPE).communicate()[0]

def tugboat_droplets():
  """Returns an Iterable of host, ip pairs."""
  output = collect_stdout(['tugboat', 'droplets'])
  for x in output.split("\n"):
    m = re.match("([\w-]+)\s*\(ip:\s*(\d+\.\d+\.\d+\.\d+)", x)
    if m:
      host = m.group(1)
      ip = m.group(2)
      yield (host, ip) 

"""
Typical output from tugboat:

amion (ip: 104.236.145.46, status: active, region: 3, id: 3563493)
htest (ip: 45.55.156.136, status: active, region: 8, id: 5613507)
"""

def plural(n, sing, plur):
  if n == 1:
    return sing
  else:
    return plur

def ssh_config_path(opts):
  if opts.c:
    return opts.c
  else:
    home = os.getenv('HOME')
    return os.path.join(home, ".ssh/config")

def main(argv):
  parser = make_parser()
  opts = parser.parse_args()

  if opts.which == "sync":
    config_path = ssh_config_path(opts)
    config = read_ssh_config(config_path)

    added = 0
    for host, ip in tugboat_droplets():
      add_droplet(config, host, ip)
      print "adding {0} -> {1}".format(host, ip)
      added += 1
    print "Hosts added:", added

    if opts.n:
      print config.serialize()
    else:
      if opts.o:
        output_path = opts.o
      else:
        output_path = config_path
      write_file(output_path, config.serialize())
      print "New ssh config written to", output_path

  elif opts.which == "list":
    output = collect_stdout(['tugboat', 'droplets'])
    for host, ip in tugboat_droplets():
      print host, ip

  elif opts.which == "ip":
    config_path = ssh_config_path(opts)
    config = read_ssh_config(config_path)
    for host, stanza, d in config.stanza_attrs():
      if host in opts.hosts:
        if 'hostname' in d:
          print d['hostname']

  else:
    print "huh???"

if __name__ == '__main__':
  main(sys.argv)
