#!/usr/bin/env python
#
# Create a ssh_config file from the output of tugboat.

import sys
import os.path
import re
from subprocess import call , Popen, PIPE

import argparse

def make_parser():
  parser = argparse.ArgumentParser()

  subp = parser.add_subparsers(title = "Subcommands")

  listp = subp.add_parser("list")
  listp.set_defaults(which = 'list')

  sshp = subp.add_parser("ssh")
  sshp.add_argument('args', nargs=argparse.REMAINDER)
  sshp.set_defaults(which = 'ssh')

  syncp = subp.add_parser("sync")
  syncp.set_defaults(which = 'sync')

  return parser

class error(Exception):
  def __init__(self, msg):
    self.msg = msg

class Stanza():
  def __init__(self, host, lines):
    self.host = host
    self.lines = lines
    self.attrs = None

  def properties(self):
    """Return the dictionary of properties."""
    if not self.attrs:
      self.attrs = self.__properties__() # generate the attribute value pairs
    return self.attrs

  def is_host_stanza(self):
    return self.host is not None

  def attr(self, name, default=None):
    return self.properties().get(name, default)

  def is_droplet(self):
    return self.is_host_stanza() and self.attr('__droplet__')

  def __properties__(self):
    """Return a dictionary of attribute values."""
    d = {}
    for x in self.lines:
      m = re.match("\s*(\w+)\s+(.*)", x)
      if m:
        d[ m.group(1).lower() ] = m.group(2)
      elif re.match("\s*# droplet", x):
        d[ "__droplet__" ] = True
    return d

  def format(self):
    return ''.join( [ x + '\n' for x in self.lines ] )

class SshConfig():
  def __init__(self, stanzas):
    self.stanzas = stanzas

  def stanza_attrs(self):
    """Iterate through the stanzas."""
    for s in self.stanzas:
      if s.is_host_stanza():
        d = s.attrs()
      else:
        d = {}
      yield s.host, s, d

  def dump(self):
    for i, s in enumerate(self.stanzas, 1):
      h = s.host
      if s.host is None:
        h = "---"
      print "Stanza", i, " Host:", h
      for x in s.lines:
        print "  |" + x

  def format(self):
    """Reconstruct the config file - trimming any trailing blank lines"""
    content = ''.join([ s.format() for s in self.stanzas ])
    content = re.sub('\s+\Z', '\n', content)
    return content

  def add_stanza(self, s):
    self.stanzas.append(s)

# types of stanzas:
#   - non-host group of lines
#   - a Host stanza

def find_hostname(config, name):
  """Find a stanza for a host name."""
  for i, s in enumerate(config.stanzas):
    if s.is_host_stanza():
      if name == s.attr('hostname', ""):
        return i
  return None

def add_stanza(config, name, stanza):
  """Add a stanza for a host name."""
  if find_hostname(config, name) is None:
    config.append(stanza)
  else:
    raise "hostname already exists"

def del_stanza(config, name):
  """Remove a stanza for a hostname."""
  i = find_hostname(config, name)
  if i is not None:
    config.stanza.pop(i)
  return i

def parse_ssh_config(lines):
  host = None
  stanzas = []
  s = []          # the current stanza
  for x in lines:
    m = re.match('\s*Host\s+(.*)', x)
    if m:
      if s:
        stanzas.append( Stanza(host, s) )
        host = m.group(1)
        s = []
    s.append(x)
  ssh_config = SshConfig(stanzas)
  return ssh_config

def cmd_list(config):
  droplets = [ s for s in config.stanzas if s.is_droplet() ]
  for s in droplets:
    host = s.host
    hname = s.attr('hostname', "???")
    user = s.attr('user', None)
    if user is None:
      u = ""
    else:
      u = " user: " + user
    print '{:<16} {:<20} {}'.format(hname, host, u)

def add_droplet(config, name, ip, user=None, idfile=None):
  """Add a droplet stanza to a SshConfig."""
  lines = ["Host " + name, "  # droplet", "  Hostname " + ip]
  if user:
    lines.append("  User " + user)
  if idfile:
    lines.append("  IdentityFile " + idfile)
  lines.append("")
  s = Stanza(name, lines)
  i = find_hostname(config, name)
  if i is not None:
    raise error("an entry for hostname " + name + " already exists.")
  else:
    config.add_stanza(s)

def cmd_delete(config, name):
  """Delete all droplets matching name. Return the number of stanzas deleted."""
  new = []
  dropped = 0
  for s in config.stanzas:
    if s.is_droplet() and s.host == name:
      dropped += 1
      continue
    new.append(s)
  config.stanzas = new
  print "Removed entries:", dropped

def read_file(path):
  with open (path) as f:
    contents = f.read()
    return contents

def write_file(path, contents):
  with open(path, "w") as f:
    f.write(contents)

def read_ssh_config(path):
  lines = read_file(path).split('\n')
  c = parse_ssh_config(lines)
  return c

def add_from_tugboat_output(config, tugboat_output):
  """Regenerate the ssh_config file from the output of tugboat."""
  added = 0
  lines = tugboat_output.split('\n')
  for x in tugboat_output.split('\n'):
    m = re.match("([\w-]+)\s*\(ip:\s*(\d+\.\d+\.\d+\.\d+)", x)
    if m:
      host = m.group(1)
      ip = m.group(2)
      add_droplet(config, host, ip)
      print "adding {0} -> {1}".format(host, ip)
      added += 1
  return added

def collect_stdout(cmd):
  return Popen(cmd, stdout=PIPE).communicate()[0]

def recreate_ssh_config(config):
  """Call tugboat to determine all droplets and regenerate the ssh config."""
  output = collect_stdout(['tugboat', 'droplets'])
  return add_from_tugboat_output(config, output)

"""
Typical output from tugboat:

amion (ip: 104.236.145.46, status: active, region: 3, id: 3563493)
htest (ip: 45.55.156.136, status: active, region: 8, id: 5613507)
"""

def plural(n, sing, plur):
  if n == 1:
    return sing
  else:
    return plur

def cmd_sync(config, path):
  new = SshConfig([])
  n = recreate_ssh_config(new)
  write_file(path, new.format())
  if n == 0:
    print "No droplets returned by tugboart."
  else:
    print n, plural(n, "droplet", "droplets"), "written to", path

def main(argv):
  home = os.getenv('HOME')
  config_path = os.path.join(home, ".do_ssh_config")
  config = read_ssh_config(config_path)
  cmd_sync(config, config_path)

def main2():
  """Note: this is not used."""
  p = make_parser()
  ns = p.parse_args(sys.argv[1:])

  home = os.getenv('HOME')
  config_path = os.path.join(home, ".do_ssh_config")
  config = read_ssh_config(config_path)

  cmd = ns.which
  if cmd == 'list':
    cmd_list(config)
  elif cmd == 'sync':
    cmd_sync(config, config_path)
  elif cmd == 'ssh':
    print "sshing... (not implemented)"
    pass

if __name__ == '__main__':
  main(sys.argv)
